// -----------------------------------------------------------------------------
//  THIS FILE IS AUTO-GENERATED. DO NOT EDIT DIRECTLY.
//
//  Generated by: Peripheral Register File Generator
//  Repository:   https://github.com/Biggo03/Peripheral-Register-File-Generator
//  Revision:     3efc313
//  Generated on: 2026-02-21T17:44:23Z
//
//  Any manual changes will be overwritten.
// -----------------------------------------------------------------------------
`timescale 1ns / 1ps
`include "uart_reg_macros.sv"
import uart_reg_pkg::*;

module uart_regfile_tb;

    // ------------------------------------------------------------
    //  Parameters
    // ------------------------------------------------------------
    localparam CLK_PERIOD = 10ns;

    // ------------------------------------------------------------
    //  u_dut Signals
    // ------------------------------------------------------------
    logic         clk_i;
    logic         reset_i;

    // -- Register Groups --
    uart_reg_pkg::config_reg_t config_grp;
    uart_reg_pkg::status_reg_t status_grp;

    // -- Write Signals --
    logic         reg_we_i;
    logic [4:0]  reg_waddr_i;
    logic [31:0]  reg_wdata_i;

    // -- Read Signals --
    logic [4:0] reg_raddr_i;
    logic [31:0] reg_rdata_o;

    // ------------------------------------------------------------
    //  Testbench Signals
    // ------------------------------------------------------------
    logic [31:0] tb_rdata;
    logic [31:0] tb_wdata;

    logic [31:0] intermediate_data;

    logic [63:0] clk_counter;
    int          error_cnt;
    // ------------------------------------------------------------
    //  Clock and Reset Generation
    // ------------------------------------------------------------
    initial begin
        clk_i = 0;
        forever #(CLK_PERIOD/2) clk_i = ~clk_i;
    end

    task automatic apply_reset();
    begin
        tb_rdata = 0;
        tb_wdata = 0;
        clk_counter = 0;
        error_cnt = 0;

    // status registers don't have write permission
    // Therefore reset is not controlled by regfile
        
        status_grp.RX_VALID = 1'h0;
        status_grp.RX_OVRN = 1'h0;
        status_grp.RX_LVL = 4'h0;
        status_grp.RX_BUSY = 1'h0;
        status_grp.TX_OVRN = 1'h0;
        status_grp.TX_LVL = 4'h0;
        status_grp.TX_BUSY = 1'h0;
        
        status_grp.RX_DATA = 8'h00;
        
    

        reset_i      = 1'b1;
        reg_we_i     = 1'b0;
        reg_waddr_i  = '0;
        reg_wdata_i  = '0;
        reg_raddr_i  = '0;
        repeat (5) @(posedge clk_i);
        reset_i = 1'b0;
    end
    endtask

    // ------------------------------------------------------------
    //  Register Tasks
    // ------------------------------------------------------------
    task write_register(
        input logic [4:0] waddr,
        input logic [31:0] wdata
    );
    begin
        reg_we_i = 1'b1;
        reg_waddr_i = waddr;
        reg_wdata_i = wdata;
        $display("[%t] Writing data %h to address %h", $realtime, wdata, waddr);
        @(posedge clk_i);
        #1;
        reg_we_i = 1'b0;
    end
    endtask

    task read_register(
        input logic [4:0] raddr,
        output logic [31:0] rdata
    );
    begin
        reg_raddr_i = raddr;
        @(negedge clk_i);
        rdata = reg_rdata_o;
        $display("[%t] Read value %h from address %h", $realtime, rdata, raddr);
    end
    endtask

    // ------------------------------------------------------------
    //  u_dut Instantiation
    // ------------------------------------------------------------
    uart_regfile u_dut (
        // -- Clk and Reset --
        .clk_i       (clk_i),
        .reset_i     (reset_i),

        // -- Register Groups --
        .config_grp (config_grp),
        .status_grp (status_grp),

        // -- Write Signals --
        .reg_we_i    (reg_we_i),
        .reg_waddr_i (reg_waddr_i),
        .reg_wdata_i (reg_wdata_i),

        // -- Read Signals --
        .reg_raddr_i (reg_raddr_i),
        .reg_rdata_o (reg_rdata_o)
    );

    initial begin
        $dumpfile("sim.vcd");
        $dumpvars(0, uart_regfile_tb);

        $display("==== Starting uart Register File Test ====");
        apply_reset();

        // Check reset
        $display("[%t] Beginning reset check...", $realtime);
        
        // Checking fields for register UART_CFG
        if (u_dut.config_grp.TX_EN != 1'h0) begin
            $display("TX_EN reset value incorrect");
            error_cnt++;
        end
        if (u_dut.config_grp.TX_CLR_OVRN != 1'h0) begin
            $display("TX_CLR_OVRN reset value incorrect");
            error_cnt++;
        end
        if (u_dut.config_grp.RX_EN != 1'h0) begin
            $display("RX_EN reset value incorrect");
            error_cnt++;
        end
        if (u_dut.config_grp.RX_CLR_OVRN != 1'h0) begin
            $display("RX_CLR_OVRN reset value incorrect");
            error_cnt++;
        end
        
        // Checking fields for register TX_DATA
        if (u_dut.config_grp.TX_DATA != 8'h00) begin
            $display("TX_DATA reset value incorrect");
            error_cnt++;
        end
        
        // Checking fields for register BAUD_CFG
        if (u_dut.config_grp.BAUDDIV != 16'h0029) begin
            $display("BAUDDIV reset value incorrect");
            error_cnt++;
        end
        
        
        // Checking fields for register UART_STATUS
        if (u_dut.status_grp.RX_VALID != 1'h0) begin
            $display("RX_VALID reset value incorrect");
            error_cnt++;
        end
        if (u_dut.status_grp.RX_OVRN != 1'h0) begin
            $display("RX_OVRN reset value incorrect");
            error_cnt++;
        end
        if (u_dut.status_grp.RX_LVL != 4'h0) begin
            $display("RX_LVL reset value incorrect");
            error_cnt++;
        end
        if (u_dut.status_grp.RX_BUSY != 1'h0) begin
            $display("RX_BUSY reset value incorrect");
            error_cnt++;
        end
        if (u_dut.status_grp.TX_OVRN != 1'h0) begin
            $display("TX_OVRN reset value incorrect");
            error_cnt++;
        end
        if (u_dut.status_grp.TX_LVL != 4'h0) begin
            $display("TX_LVL reset value incorrect");
            error_cnt++;
        end
        if (u_dut.status_grp.TX_BUSY != 1'h0) begin
            $display("TX_BUSY reset value incorrect");
            error_cnt++;
        end
        
        // Checking fields for register RX_DATA
        if (u_dut.status_grp.RX_DATA != 8'h00) begin
            $display("RX_DATA reset value incorrect");
            error_cnt++;
        end
        

        //Readcheck for registers
        $display("[%t] Beginning read check for registers...", $realtime);
        
        // Reading register UART_CFG
        read_register(`UART_UART_CFG_ADDR, tb_rdata);
        if (reg_rdata_o[0] != 1'h0) begin
            $display("Reset check for TX_EN failed");
            error_cnt++;
        end
        if (reg_rdata_o[1] != 1'h0) begin
            $display("Reset check for TX_CLR_OVRN failed");
            error_cnt++;
        end
        if (reg_rdata_o[2] != 1'h0) begin
            $display("Reset check for RX_EN failed");
            error_cnt++;
        end
        if (reg_rdata_o[3] != 1'h0) begin
            $display("Reset check for RX_CLR_OVRN failed");
            error_cnt++;
        end
        // Reading register TX_DATA
        read_register(`UART_TX_DATA_ADDR, tb_rdata);
        if (reg_rdata_o[7:0] != 8'h00) begin
            $display("Reset check for TX_DATA failed");
            error_cnt++;
        end
        // Reading register BAUD_CFG
        read_register(`UART_BAUD_CFG_ADDR, tb_rdata);
        if (reg_rdata_o[15:0] != 16'h0029) begin
            $display("Reset check for BAUDDIV failed");
            error_cnt++;
        end
        
        // Reading register UART_STATUS
        read_register(`UART_UART_STATUS_ADDR, tb_rdata);
        if (reg_rdata_o[0] != 1'h0) begin
            $display("Reset check for RX_VALID failed");
            error_cnt++;
        end
        if (reg_rdata_o[1] != 1'h0) begin
            $display("Reset check for RX_OVRN failed");
            error_cnt++;
        end
        if (reg_rdata_o[5:2] != 4'h0) begin
            $display("Reset check for RX_LVL failed");
            error_cnt++;
        end
        if (reg_rdata_o[6] != 1'h0) begin
            $display("Reset check for RX_BUSY failed");
            error_cnt++;
        end
        if (reg_rdata_o[7] != 1'h0) begin
            $display("Reset check for TX_OVRN failed");
            error_cnt++;
        end
        if (reg_rdata_o[11:8] != 4'h0) begin
            $display("Reset check for TX_LVL failed");
            error_cnt++;
        end
        if (reg_rdata_o[12] != 1'h0) begin
            $display("Reset check for TX_BUSY failed");
            error_cnt++;
        end
        // Reading register RX_DATA
        read_register(`UART_RX_DATA_ADDR, tb_rdata);
        if (reg_rdata_o[7:0] != 8'h00) begin
            $display("Reset check for RX_DATA failed");
            error_cnt++;
        end

        // Writecheck for all W access groups
        $display("[%t] Beginning write check for all writable registers...", $realtime);
        
        tb_wdata = $urandom();
        write_register(`UART_UART_CFG_ADDR, tb_wdata);
        read_register(`UART_UART_CFG_ADDR, tb_rdata);
        if (reg_rdata_o[0] != tb_wdata[0] || config_grp.TX_EN != tb_wdata[0]) begin
            $display("Write check for TX_EN failed");
            error_cnt++;
        end
        if (reg_rdata_o[1] != tb_wdata[1] || config_grp.TX_CLR_OVRN != tb_wdata[1]) begin
            $display("Write check for TX_CLR_OVRN failed");
            error_cnt++;
        end
        if (reg_rdata_o[2] != tb_wdata[2] || config_grp.RX_EN != tb_wdata[2]) begin
            $display("Write check for RX_EN failed");
            error_cnt++;
        end
        if (reg_rdata_o[3] != tb_wdata[3] || config_grp.RX_CLR_OVRN != tb_wdata[3]) begin
            $display("Write check for RX_CLR_OVRN failed");
            error_cnt++;
        end
        
        tb_wdata = $urandom();
        write_register(`UART_TX_DATA_ADDR, tb_wdata);
        read_register(`UART_TX_DATA_ADDR, tb_rdata);
        if (reg_rdata_o[7:0] != tb_wdata[7:0] || config_grp.TX_DATA != tb_wdata[7:0]) begin
            $display("Write check for TX_DATA failed");
            error_cnt++;
        end
        
        tb_wdata = $urandom();
        write_register(`UART_BAUD_CFG_ADDR, tb_wdata);
        read_register(`UART_BAUD_CFG_ADDR, tb_rdata);
        if (reg_rdata_o[15:0] != tb_wdata[15:0] || config_grp.BAUDDIV != tb_wdata[15:0]) begin
            $display("Write check for BAUDDIV failed");
            error_cnt++;
        end
        
    

        // Update check for all read only registers (from software perspective)
        $display("[%t] Beginning update check for all read only registers...", $realtime);
        
        // Set raddr to register UART_STATUS
        reg_raddr_i = `UART_UART_STATUS_ADDR;

        // Write all fields in register to all 1's
        status_grp.RX_VALID = '1;
        @(negedge clk_i);
        if (reg_rdata_o[0] != '1) begin
            $display("update check for RX_VALID failed");
            error_cnt++;
        end else begin
            $display("[%t] Read %0b from RX_VALID", $realtime, reg_rdata_o[0]);
        end
        status_grp.RX_OVRN = '1;
        @(negedge clk_i);
        if (reg_rdata_o[1] != '1) begin
            $display("update check for RX_OVRN failed");
            error_cnt++;
        end else begin
            $display("[%t] Read %0b from RX_OVRN", $realtime, reg_rdata_o[1]);
        end
        status_grp.RX_LVL = '1;
        @(negedge clk_i);
        if (reg_rdata_o[5:2] != '1) begin
            $display("update check for RX_LVL failed");
            error_cnt++;
        end else begin
            $display("[%t] Read %0b from RX_LVL", $realtime, reg_rdata_o[5:2]);
        end
        status_grp.RX_BUSY = '1;
        @(negedge clk_i);
        if (reg_rdata_o[6] != '1) begin
            $display("update check for RX_BUSY failed");
            error_cnt++;
        end else begin
            $display("[%t] Read %0b from RX_BUSY", $realtime, reg_rdata_o[6]);
        end
        status_grp.TX_OVRN = '1;
        @(negedge clk_i);
        if (reg_rdata_o[7] != '1) begin
            $display("update check for TX_OVRN failed");
            error_cnt++;
        end else begin
            $display("[%t] Read %0b from TX_OVRN", $realtime, reg_rdata_o[7]);
        end
        status_grp.TX_LVL = '1;
        @(negedge clk_i);
        if (reg_rdata_o[11:8] != '1) begin
            $display("update check for TX_LVL failed");
            error_cnt++;
        end else begin
            $display("[%t] Read %0b from TX_LVL", $realtime, reg_rdata_o[11:8]);
        end
        status_grp.TX_BUSY = '1;
        @(negedge clk_i);
        if (reg_rdata_o[12] != '1) begin
            $display("update check for TX_BUSY failed");
            error_cnt++;
        end else begin
            $display("[%t] Read %0b from TX_BUSY", $realtime, reg_rdata_o[12]);
        end
        // Set raddr to register RX_DATA
        reg_raddr_i = `UART_RX_DATA_ADDR;

        // Write all fields in register to all 1's
        status_grp.RX_DATA = '1;
        @(negedge clk_i);
        if (reg_rdata_o[7:0] != '1) begin
            $display("update check for RX_DATA failed");
            error_cnt++;
        end else begin
            $display("[%t] Read %0b from RX_DATA", $realtime, reg_rdata_o[7:0]);
        end
    

        #100;
        if (error_cnt == 0) $display("TEST PASSED");
        else $display("TEST FAILED");
        $finish;
    end

endmodule
